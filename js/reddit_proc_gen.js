"use strict";var isNode="undefined"!=typeof module,reddit_proc_gen=function(){var TAU=2*Math.PI,bmp=dom.canvas(1,1),ctx=bmp.ctx,border=void 0,cutHalf=void 0,maxDepth=void 0,minArea=void 0,radius=void 0,sh=void 0,size=void 0,sw=void 0,settings={spread:{type:"Number",label:"Spread",min:1,max:10,cur:10},maxDepth:{type:"Number",label:"Max Depth",min:2,max:8,cur:2}},drawPolygon=function(points,_ref){var lineWidth=_ref.lineWidth,strokeStyle=_ref.strokeStyle,fillStyle=_ref.fillStyle;points&&(ctx.beginPath(),points.forEach(function(p,i){ctx[0==i?"moveTo":"lineTo"](p.x*sw,p.y*sh)}),ctx.closePath(),lineWidth&&strokeStyle&&(ctx.strokeStyle=strokeStyle,ctx.lineWidth=lineWidth*size,ctx.stroke()),fillStyle&&(ctx.fillStyle=fillStyle,ctx.fill()))},c=0,drawAndSplit=function drawAndSplit(points,depth){var polygons=function(array){for(var cornerAlpha=rand.getInteger(0,array.length-1),cornerBeta=(cornerAlpha+rand.getInteger(1,array.length-1))%array.length,cornerMin=Math.min(cornerAlpha,cornerBeta),cornerMax=Math.max(cornerAlpha,cornerBeta),pointA0=array[cornerMin],pointA1=array[(cornerMin+1)%array.length],pointB0=array[cornerMax],pointB1=array[(cornerMax+1)%array.length],pointA=geom.lerp(pointA0,pointA1,cutHalf?.5:rand.getNumber(.1,.9)),pointB=geom.lerp(pointB0,pointB1,cutHalf?.5:rand.getNumber(.1,.9)),arrayMin=[],arrayMax=[],i=0;i<array.length;)i<=cornerMin?arrayMin.push(array[i]):cornerMin<i&&i<=cornerMax?(arrayMin.push(pointA,pointB),i=cornerMax):arrayMin.push(array[i]),i++;for(i=cornerMin+1,arrayMax.push(pointB,pointA);i<cornerMax+1;)arrayMax.push(array[i]),i++;return[arrayMin,arrayMax]}(points);depth++,polygons.forEach(function(poly){if(depth<settings.maxDepth.cur&&(0===minArea||geom.polygonArea(poly)>minArea))drawAndSplit(poly,depth);else{var polyInset=geom.insetPoints(poly,border);if(!polyInset)return;for(var len=polyInset.length,j=0;j<len-1;j++)for(var indexB=j+1,pointA=polyInset[j],pointB=polyInset[indexB],i=indexB;i<len;i++){c++;var indexD=(i+1)%len,pointC=polyInset[i],pointD=polyInset[indexD];if(geom.intersectionBetweenPoints(pointA,pointB,pointC,pointD))return}drawPolygon(polyInset,function(){var style={};switch(rand.getInteger(0,8)){case 0:style.lineWidth=.001,style.strokeStyle=colours.getRandomColour();break;case 1:case 2:var width=0,height=0;0===rand.getInteger(0,1)?width=2*radius:height=2*radius;var gradient=ctx.createLinearGradient(.5-radius,.5-radius,width*sw,height*sh);gradient.addColorStop(0,colours.getRandomColour()),gradient.addColorStop(1,colours.getRandomColour()),style.fillStyle=gradient;break;default:style.fillStyle=colours.getRandomColour()}return style}())}})},init=function(options){size=options.size,sw=options.sw||size,sh=options.sh||size,colours.getRandomPalette(),bmp.setSize(sw,sh),ctx.clearRect(0,0,sw,sh),border=-rand.getNumber(.002,.01),radius=rand.getNumber(.3,.5),cutHalf=.2<rand.getNumber(0,1),minArea=0===rand.getInteger(0,1)?0:rand.getNumber(.05,.8*radius),maxDepth=rand.getInteger(2,8),settings.spread.cur=rand.getInteger(0,10),settings.maxDepth.cur=maxDepth,options.settings&&(settings=options.settings),progress("settings:initialised",settings),con.log(minArea,maxDepth);var sides=rand.getInteger(3,7),startAngle=settings.spread.cur/10*1/sides*TAU,points=new Array(sides).fill().map(function(side,i){var a=startAngle+i/sides*-TAU;return{x:.5+Math.sin(a)*radius,y:.5+Math.cos(a)*radius}});drawPolygon(points,{strokeStyle:colours.getRandomColour(),lineWidth:.001}),drawAndSplit(geom.insetPoints(points,border),0),progress("render:complete",bmp.canvas),console.log("calculations",c)};return con.log("ok"),{stage:bmp.canvas,init:init,settings:settings,update:function(settings){con.log("update",settings),init({size:size,settings:settings})}}};isNode?module.exports=reddit_proc_gen():define("reddit_proc_gen",reddit_proc_gen);