"use strict";var vertexShader="\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vLocalPosition;\nvoid main() {\n\tvPosition = position;\n\tvNormal = normalize(normalMatrix * normal);\n\tvLocalPosition = position;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader="\nprecision mediump float;\nuniform float time;\nuniform vec3 baseColor;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vLocalPosition;\n\nfloat hash(float n) {\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tfloat n = i.x + i.y * 57.0 + 113.0 * i.z;\n\treturn mix(\n\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, float time) {\n\tfloat value = 0.0;\n\tfloat amplitude = 0.5;\n\tfloat frequency = (cos((time + 100.0) * 0.08) + sin(time * 0.12) + 2.5) * 0.1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tvalue += amplitude * noise(p * frequency);\n\t\tfrequency *= 2.0;\n\t\tamplitude *= 0.5;\n\t}\n\treturn value;\n}\n\nvoid main() {\n\tvec3 pos = vLocalPosition * 0.05;\n\tpos += vec3(time * 0.0, time * 0.0, time * 0.0);\n\tfloat noiseValue = fbm(pos, time * 0.001);\n\tfloat blob = smoothstep(0.3, 0.7, noiseValue);\n\tblob = pow(blob, 1.5);\n\tfloat detail = fbm(pos * 3.0, 1.0);\n\tblob = mix(blob, detail * 0.5 + 0.5, 0.3);\n\tvec3 color1 = vec3(0.1, 0.0, 0.0);\n\tvec3 color2 = vec3(0.8, 0.2, 0.1);\n\tvec3 color = mix(color1, color2, blob);\n\tfloat glow = pow(blob, 2.0) * 0.3;\n\tcolor += vec3(0.5, 0.4, 0.3) * glow;\n\tvec3 lightDir = normalize(vec3(0.0, 1.0, 0.5));\n\tfloat diff = max(dot(vNormal, lightDir), 0.3);\n\tcolor *= diff;\n\tgl_FragColor = vec4(color, 1.0);\n}\n";define("maze_cube",["linked_line"],function(linkedLine){var camera,scene,renderer,holder,materialShader,uniforms,blocks=11,cubeSize=1512,size=cubeSize/blocks,mouse={x:0,y:0,toggle:!0},camPos={x:0,y:0,z:0},sw=window.innerWidth,sh=window.innerHeight;function cube(w,h,d,materialType,materialIndex){var material,group=new THREE.Group,geometry=new THREE.BoxGeometry(w,h,d);switch(materialType){case"shader":material=materialShader;break;case"phong":material=materialPhongStack.at(materialIndex)}var object=new THREE.Mesh(geometry,material);return object.castShadow=!0,object.receiveShadow=!0,group.add(object),group}var materialPhongStack=[];var modes=[{axis:"x",target:Math.PI/2},{axis:"z",target:Math.PI/2},{axis:"x",target:Math.PI},{axis:"y",target:Math.PI/2},{axis:"z",target:Math.PI},{axis:"y",target:Math.PI}],rotationMode=0,rotationSpeed=.001*Math.PI,rotationState=modes[rotationMode];function render(time){if(mouse.toggle){var axis=rotationState.axis;holder.rotation[axis]+=rotationSpeed,holder.rotation[axis]>=rotationState.target&&(holder.rotation[axis]=rotationState.target,5<++rotationMode&&(rotationMode=0,holder.rotation.x=0,holder.rotation.y=0,holder.rotation.z=0),rotationState=modes[rotationMode])}uniforms.time.value=time,camPos.z=5e3,camera.position.set(camPos.x,camPos.y,camPos.z),camera.lookAt(scene.position),renderer.render(scene,camera),requestAnimationFrame(render)}return{init:function(){var mazes=[],face=function(preoccupied){return linkedLine.generate(blocks,preoccupied)},add=function(maze){mazes.push(maze.wallrects),progress("render:progress",mazes.length/6)};perf.start("gen"),face().then(add).then(function(){return face([{x:1,y:2},{x:1,y:3},{x:3,y:3}])}).then(add).then(face).then(add).then(face).then(add).then(face).then(add).then(face).then(add).then(function(){perf.end("gen"),function(mazes){(scene=new THREE.Scene).fog=new THREE.FogExp2(0,2e-4),camera=new THREE.PerspectiveCamera(90,sw/sh,1,2e4),scene.add(camera);var lightFront=new THREE.DirectionalLight(9437184,1);lightFront.castShadow=!0,lightFront.position.set(0,0,1),scene.add(lightFront);var lightAbove=new THREE.DirectionalLight(16777215,.5);lightAbove.castShadow=!0,lightAbove.position.set(0,1,0),scene.add(lightAbove);var lightLeft=new THREE.DirectionalLight(16777215,.5);lightLeft.castShadow=!0,lightLeft.position.set(-1,0,0),scene.add(lightLeft),materialPhongStack=new Array(6).fill(0).map(function(){var r=32+32*Math.random(),b=16+Math.random()*r;return new THREE.MeshPhongMaterial({color:r<<16|0|b,emissive:1052688,specular:6291456,shininess:100})}),uniforms={time:{value:0},baseColor:{value:new THREE.Color(16711935)}},materialShader=new THREE.ShaderMaterial({vertexShader:vertexShader,fragmentShader:fragmentShader,uniforms:uniforms,fog:!1}),(renderer=new THREE.WebGLRenderer).setSize(sw,sh),renderer.shadowMap={type:THREE.BasicShadowMap,enabled:!0},holder=new THREE.Group,scene.add(holder);var lavaCubeSize=2*cubeSize,c=cube(lavaCubeSize,lavaCubeSize,lavaCubeSize,"shader");holder.add(c);var makeFace=function(options){var face=new THREE.Group;holder.add(face),options.maze.forEach(function(item){var x=(item.x+item.w/2-blocks-.5)*size,y=(item.y+item.h/2-blocks-.5)*size,z=cubeSize+10,c=cube(item.w*size,item.h*size,size,"phong",options.index);c.position.set(x,y,z),face.add(c)}),options.rotation.x&&(face.rotation.x=options.rotation.x*Math.PI),options.rotation.y&&(face.rotation.y=options.rotation.y*Math.PI),options.rotation.z&&(face.rotation.z=options.rotation.z*Math.PI)};function toggle(){mouse.toggle=!mouse.toggle}makeFace({maze:mazes[0],rotation:{x:0},index:0}),makeFace({maze:mazes[1],rotation:{x:1,z:1.5},index:1}),makeFace({maze:mazes[2],rotation:{x:.5,z:.5},index:2}),makeFace({maze:mazes[3],rotation:{x:1.5,z:1},index:3}),makeFace({maze:mazes[4],rotation:{y:.5,z:1.5},index:4}),makeFace({maze:mazes[5],rotation:{y:1.5,z:1},index:5}),document.body.appendChild(renderer.domElement),progress("render:complete",renderer.domElement),render(0),window.addEventListener("click",toggle),window.addEventListener("touchstart",toggle)}(mazes)}).catch(function(err){})}}});