"use strict";var _slicedToArray=function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return function(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{!_n&&_i.return&&_i.return()}finally{if(_d)throw _e}}return _arr}(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")},number=function(min,max){return fxrand()*(max-min)+min},integer=function(min,max){return~~number(min,max+1)},colourMutate=function(_ref){var _ref2=_slicedToArray(_ref,3),r=_ref2[0],g=_ref2[1],b=_ref2[2],amount=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;return"rgb("+[r,g,b].map(function(channel){return~~number(channel-amount,channel+amount)}).join(",")+")"},limitVisible=function(v){return Math.min(Math.max(v,30),250)},modAm=20,greyMod=[0,0,0].map(function(){return number(-1,1)*modAm}),highlight=[0,0,0].map(function(_,i){return limitVisible(~~number(50,240)+greyMod[i])});function colourGrey(options){var defaults={darkest:0,lightest:255,alpha:1};for(var p in options)defaults[p]=options[p];var white=defaults.white||integer(defaults.darkest,defaults.lightest);return"rgba("+limitVisible(white+greyMod[0])+","+limitVisible(white+greyMod[1])+","+limitVisible(white+greyMod[2])+","+defaults.alpha+")"}function makeCanvas(w,h){var can=document.createElement("canvas");return can.width=w,can.height=h,can}function generateNoise(w,h,options){var defaults={darkest:1,lightest:4,alpha:.3,percentage:0};for(var p in options)defaults[p]=options[p];for(var canvas=makeCanvas(w,h),ctx=canvas.getContext("2d"),x=0;x<w;x++)for(var y=0;y<h;y++)number(0,1)>defaults.percentage&&(ctx.fillStyle=colourGrey(defaults),ctx.fillRect(x,y,1,1));return canvas}var noise=void 0;function generateMetal(w,h){noise=noise||generateNoise(300,300,{percentage:.1});var canvas=makeCanvas(w,h),ctx=canvas.getContext("2d");return ctx.fillStyle=colourGrey({darkest:0,lightest:90,alpha:1}),ctx.fillRect(0,0,w,h),ctx.drawImage(noise,0,0),canvas}function drawCircle(c,x,y,r,style){c.moveTo(x+r,y);var defaults={fillStyle:"#fff",lineWidth:0,strokeStyle:"#000"};for(var p in style)defaults[p]=style[p];c.fillStyle=defaults.fillStyle,c.lineWidth=defaults.lineWidth,c.strokeStyle=defaults.strokeStyle,c.beginPath(),c.arc(x,y,r,0,pi2,!0),c.closePath(),defaults.fillStyle&&c.fill(),defaults.lineWidth&&c.stroke()}function drawBand(ctx,minRadius,maxRadius){var bandSize=maxRadius-minRadius;drawCircle(ctx,0,0,(maxRadius+minRadius)/2,{fillStyle:null,strokeStyle:.7<number(0,1)?colourMutate(highlight,20):colourGrey(),lineWidth:bandSize})}function drawCutouts(ctx,teeth,minRadius,maxRadius){var midRadius=(maxRadius+minRadius)/2,bandSize=maxRadius-minRadius;switch(integer(1,2)){case 1:generateHoles(ctx,teeth,midRadius,bandSize);break;case 2:generateSegment(ctx,teeth,midRadius,bandSize)}}function generateHoles(ctx,teeth,midRadius,bandSize){var holeSize=bandSize/2*number(.6,.9),holes=~~(number(.5,.9)*pi2*midRadius/holeSize/2);holeSize*=number(.5,.9);for(var i=0;i<holes;i++){var angle=i/holes*pi2;drawCircle(ctx,midRadius*Math.cos(angle),midRadius*Math.sin(angle),holeSize)}}function generateSegment(ctx,teeth,midRadius,bandSize){for(var capped=0==integer(0,1),segments=1+~~Math.pow(teeth,1/integer(2,capped?4:3)),holeSize=number(.5,.8)*bandSize,segmentSize=(pi2/segments-(Math.asin(holeSize/midRadius)*capped?1:.5))*number(.5,.9),innerRadius=midRadius-holeSize/2,outerRadius=midRadius+holeSize/2,i=0;i<segments;i++){var startAngle=i/segments*pi2,endAngle=startAngle+segmentSize;ctx.beginPath(),ctx.moveTo(Math.cos(startAngle)*innerRadius,Math.sin(startAngle)*innerRadius),ctx.arc(0,0,innerRadius,startAngle,endAngle,!1),capped?ctx.arc(Math.cos(endAngle)*midRadius,Math.sin(endAngle)*midRadius,holeSize/2,endAngle+pi,endAngle,!0):ctx.lineTo(Math.cos(endAngle)*outerRadius,Math.sin(endAngle)*outerRadius),ctx.arc(0,0,outerRadius,endAngle,startAngle,!0),capped?ctx.arc(Math.cos(startAngle)*midRadius,Math.sin(startAngle)*midRadius,holeSize/2,startAngle,startAngle+pi,!0):ctx.lineTo(Math.cos(startAngle)*innerRadius,Math.sin(startAngle)*innerRadius),ctx.closePath(),ctx.fill()}}function drawSpokes(ctx,teeth,minRadius,maxRadius){var spokes=Math.min(Math.max(2,Math.floor(teeth*number(.2,1))),50),shaftBase=minRadius*Math.atan(pi/spokes)*number(.6,1),shaftTop=20<spokes?shaftBase:maxRadius*Math.atan(pi/spokes)*number(.1,.3);ctx.beginPath();for(var i=0;i<spokes;i++){var angle=i/spokes*pi2,tangent=pi/2-angle,baseOffsetX=shaftBase*Math.cos(tangent),baseOffsetY=shaftBase*Math.sin(tangent),topOffsetX=shaftTop*Math.cos(tangent),topOffsetY=shaftTop*Math.sin(tangent);ctx[0==i?"moveTo":"lineTo"](Math.cos(angle)*minRadius+baseOffsetX,Math.sin(angle)*minRadius-baseOffsetY),ctx.lineTo(Math.cos(angle)*maxRadius+topOffsetX,Math.sin(angle)*maxRadius-topOffsetY),ctx.lineTo(Math.cos(angle)*maxRadius-topOffsetX,Math.sin(angle)*maxRadius+topOffsetY),ctx.lineTo(Math.cos(angle)*minRadius-baseOffsetX,Math.sin(angle)*minRadius+baseOffsetY)}ctx.closePath(),ctx.fill()}function drawBike(ctx,minRadius,maxRadius){for(var innerRadius=1.1*minRadius,outerRadius=.9*maxRadius,spokes=integer(5,10),corners=integer(1,3),positive=2*integer(0,1)-1,o=0,offsets=Array(corners).fill().map(function(){return{offsetAngle:o+=positive*number(0,.3),offsetRadius:number(innerRadius+.3*(outerRadius-innerRadius),outerRadius)}}),lineWidth=maxRadius/10,_loop=function(){var angle=i/spokes*pi2;ctx.beginPath(),ctx.moveTo(Math.cos(angle)*innerRadius,Math.sin(angle)*innerRadius),offsets.forEach(function(_ref3,index){var offsetAngle=_ref3.offsetAngle,offsetRadius=_ref3.offsetRadius,r=index<2?outerRadius:offsetRadius;ctx.lineTo(Math.cos(angle+offsetAngle)*r,Math.sin(angle+offsetAngle)*r)}),ctx.lineJoin="round",ctx.closePath(),ctx.strokeStyle="#000",ctx.lineWidth=lineWidth,ctx.fill(),ctx.stroke()},i=0;i<spokes;i++)_loop()}function drawSeeds(ctx,minRadius,maxRadius){for(var rays=integer(5,10),theta=pi2/rays,delta=maxRadius-minRadius,startDistance=number(1.3*minRadius,1.5*minRadius),layers=Math.floor(delta/10),j=1;j<layers;j++){var distance=startDistance+1*Math.pow(j*(delta/layers),2),circleSize=Math.sin(theta/2)*distance*1.3/2*.8;if(.95*maxRadius<distance+circleSize)break;for(var i=0;i<rays;i++){var _angle=(i+j%2*.5)*theta;drawCircle(ctx,Math.cos(_angle)*distance,Math.sin(_angle)*distance,circleSize)}}}