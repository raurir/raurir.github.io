"use strict";var vertexShader="varying vec2 vUv;\nvoid main()\n{\n  vUv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n}",fragmentShader="\nuniform float r;\nuniform float g;\nuniform float b;\nuniform float distance;\nuniform float pulse;\nuniform float rows;\nuniform float cols;\nvarying vec2 vUv;\nfloat checkerRows = 1.5;\nfloat checkerCols = 2.0;\nvoid main( void ) {\n  vec2 position = abs(-1.0 + 2.0 * vUv);\n\n  float edging = abs((pow(position.y, 5.0) + pow(position.x, 5.0)) / 1.0);\n\n  float perc = 0.25 + distance * edging * 0.75;\n  vec2 checkPosition = vUv;\n  \n  float checkerX = mod(checkPosition.x, 1.0 / rows) * rows; // loop of 0 to 1 per row: /|/|/|//\n  checkerX = abs(checkerX - 0.5) * 2.0; // make up and down: /// \n  checkerX = pow(checkerX, 3.0); // power to sharpen edges: __/__/\n\n  float checkerY = mod(checkPosition.y, 1.0 / cols) * cols;\n  checkerY = abs(checkerY - 0.5) * 2.0;\n  checkerY = pow(checkerY, 3.0);\n\n  float checkerMod = 0.0;\n  if (rows > 1.0 && floor(checkPosition.x * rows) == checkerMod) {\n    perc = 2.0;\n  }\n  if (cols > 1.0 && floor(checkPosition.y * cols) == checkerMod) {\n    perc = 2.0;\n  }\n\n  // float checker = (checkerX * checkerY) * 2.0;\n  float checker = (checkerX + checkerY) * 0.5;\n  float r1 = r * checker + 0.1;\n  float g1 = g * checker + 0.05;\n  float b1 = b * checker + 0.2;\n  float red = r1 * perc + pulse;\n  float green = g1 * perc + pulse;\n  float blue = b1 * perc + pulse + 0.05;\n\n  // float red = r;\n  // float green = g;\n  // float blue = b;\n\n  gl_FragColor = vec4(red, green, blue, 1.0);\n}",perlin_grid=function(noise){var camera,scene,renderer,holderAbove,holderBelow,stage=document.createElement("div"),mouse={x:0,y:0},camPos={x:0,y:0,z:10},sw=window.innerWidth,sh=window.innerHeight,size={width:300,height:100,depth:300},gridUnits=7,gridAbove=[],gridBelow=[],seed=Math.random();function num(min,max){return Math.random()*(max-min)+min}function createMaterial(rows,cols,colourRand,distance){var colourBase_g=.3,colourBase_b=.6,colour={r:.7+colourRand.r,g:colourBase_g+colourRand.g,b:colourBase_b+colourRand.b},uniforms={r:{type:"f",value:colour.r},g:{type:"f",value:colour.g},b:{type:"f",value:colour.b},distance:{type:"f",value:distance},pulse:{type:"f",value:0},rows:{type:"f",value:rows},cols:{type:"f",value:cols}};return new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexShader,fragmentShader:fragmentShader})}function cube(options){var width=options.dimensions.width,height=options.dimensions.height,depth=options.dimensions.depth,colour=options.colour,checker=options.checker,distance=options.distance,shaderRed=createMaterial(checker[0][0],checker[0][1],colour,distance),shaderYellow=createMaterial(checker[1][0],checker[1][1],colour,distance),shaderGreen=createMaterial(checker[2][0],checker[2][1],colour,distance),shaderBlue=createMaterial(checker[3][0],checker[3][1],colour,distance),shaderCyan=createMaterial(checker[4][0],checker[4][1],colour,distance),shaderMagenta=createMaterial(checker[5][0],checker[5][1],colour,distance),geometry=new THREE.BoxGeometry(width,height,depth);return new THREE.Mesh(geometry,new THREE.MeshFaceMaterial([shaderRed,shaderYellow,shaderGreen,shaderBlue,shaderCyan,shaderMagenta]))}var draw=function(x,z,distanceFromCentre){var colourRand={r:num(0,.5),g:num(0,.5),b:num(0,.5)},vertProps={width:50,height:size.height,depth:50},distance=size.width/2-50,holder=new THREE.Group,verticalEdgeBL=cube({dimensions:vertProps,checker:[[1,2],[1,2],[1,1],[1,1],[1,2],[1,2]],colour:colourRand,distance:distanceFromCentre});verticalEdgeBL.position.set(-distance,0,-distance),holder.add(verticalEdgeBL);var verticalEdgeBR=cube({dimensions:vertProps,checker:[[1,2],[1,2],[1,1],[1,1],[1,2],[1,2]],colour:colourRand,distance:distanceFromCentre});verticalEdgeBR.position.set(distance,0,-distance),holder.add(verticalEdgeBR);var verticalEdgeFL=cube({dimensions:vertProps,checker:[[1,2],[1,2],[1,1],[1,1],[1,2],[1,2]],colour:colourRand,distance:distanceFromCentre});verticalEdgeFL.position.set(-distance,0,distance),holder.add(verticalEdgeFL);var verticalEdgeFR=cube({dimensions:vertProps,checker:[[1,2],[1,2],[1,1],[1,1],[1,2],[1,2]],colour:colourRand,distance:distanceFromCentre});verticalEdgeFR.position.set(distance,0,distance),holder.add(verticalEdgeFR);var horizProps={width:size.width-50,height:50,depth:50},horizontalEdgeF=cube({dimensions:horizProps,checker:[[1,1],[1,1],[5,1],[5,1],[5,1],[5,1]],colour:colourRand,distance:distanceFromCentre});horizontalEdgeF.position.set(0,(size.height+50)/2,-distance),holder.add(horizontalEdgeF);var horizontalEdgeB=cube({dimensions:horizProps,checker:[[1,1],[1,1],[5,1],[5,1],[5,1],[5,1]],colour:colourRand,distance:distanceFromCentre});return horizontalEdgeB.position.set(0,(size.height+50)/2,distance),holder.add(horizontalEdgeB),holder};function listen(eventNames,callback){for(var i=0;i<eventNames.length;i++)window.addEventListener(eventNames[i],callback)}function animate(time){if(requestAnimationFrame(animate),.99<Math.random()){var holder=.5<Math.random()?holderAbove:holderBelow;TweenMax.to(holder.rotation,.75,{y:Math.PI/2*Math.round(num(-2,2)),eade:Quad.easeInOut})}!function(time){var breathDistance=1+2*(1+Math.sin(.004*time));function renderBox(holder,value,x,z,above){var scale=1+50*(value*=value*value*value),px=(x-gridUnits/2+.5)*size.width*breathDistance,py=scale*size.height/2*above,pz=(z-gridUnits/2+.5)*size.depth*breathDistance;holder.position.set(px,py,pz)}for(var z=0;z<gridUnits;z++)for(var x=0;x<gridUnits;x++){var gridIndex=x+z*gridUnits,valueAbove=(noise.perlin3(x/gridUnits,z/gridUnits,seed)+1)/2,valueBelow=(noise.perlin3(x/gridUnits,z+gridUnits*gridUnits/gridUnits,seed)+1)/2,holderAbove=gridAbove[gridIndex],holderBelow=gridBelow[gridIndex];renderBox(holderAbove,valueAbove,x,z,1),renderBox(holderBelow,valueBelow,x,z,-1)}seed+=.01,camPos.x-=.02*(camPos.x-1*mouse.x),camPos.y-=.05*(camPos.y-1e3*mouse.y);var rotY=4*camPos.x;camera.position.set(400*Math.sin(rotY),camPos.y,400*Math.cos(rotY)),camera.lookAt(scene.position),renderer.render(scene,camera)}(time)}return listen(["resize"],function(e){sw=window.innerWidth,sh=window.innerHeight,camera.aspect=sw/sh,camera.updateProjectionMatrix(),renderer.setSize(sw,sh)}),listen(["mousedown","touchstart"],function(e){e.preventDefault(),!0}),listen(["mousemove","touchmove"],function(e){e.preventDefault(),e.changedTouches&&e.changedTouches[0]&&(e=e.changedTouches[0]),mouse.x=e.clientX/sw*2-1,mouse.y=-e.clientY/sh*2+1}),listen(["mouseup","touchend"],function(e){e.preventDefault(),!1}),{init:function(){var light;scene=new THREE.Scene,(camera=new THREE.PerspectiveCamera(90,sw/sh,1,1e4)).position.set(0,100,500),scene.add(camera),(light=new THREE.DirectionalLight(16777215,2)).position.set(1,1,1).normalize(),scene.add(light),(light=new THREE.DirectionalLight(16711935,2)).position.set(-1,0,0).normalize(),scene.add(light),(renderer=new THREE.WebGLRenderer({antialias:!0})).setSize(sw,sh),holderAbove=new THREE.Group,scene.add(holderAbove),holderBelow=new THREE.Group,scene.add(holderBelow);for(var x=0;x<gridUnits;x++)for(var z=0;z<gridUnits;z++){var px=(x-gridUnits/2+.5)*size.width,pz=(z-gridUnits/2+.5)*size.depth,distanceFromCentre=1-Math.sqrt(px*px+pz*pz)/1200,boxAbove=draw(0,0,distanceFromCentre);boxAbove.position.set(px,0,pz),holderAbove.add(boxAbove),gridAbove.push(boxAbove);var boxBelow=draw(0,0,distanceFromCentre);boxBelow.position.set(px,0,pz),boxBelow.rotation.set(Math.PI,Math.PI/2,0),holderBelow.add(boxBelow),gridBelow.push(boxBelow)}stage.appendChild(renderer.domElement),animate(0)},stage:stage}};define("perlin_grid",["noise"],perlin_grid);